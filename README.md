# SHA
================================================================================
SHA-256 STRUCTURAL ANALYSIS, SECURITY-MARGIN DECAY, & DEFENSIVE FRAMEWORK
(Complete, Non-Operational, Copy-Paste Master Block)
================================================================================

AUTHORSHIP CONTEXT
------------------
This document consolidates structural, algebraic, and dynamical-system analysis
of SHA-256. It demonstrates non-ideal behavior, margin decay, and theoretical
non‚Äìrandom-oracle properties WITHOUT providing executable attack pipelines,
collision engines, or fault-injection routines.

This format is suitable for:
- prior-art documentation
- cryptographic audit
- academic publication
- defensive engineering review
- post-quantum transition justification

================================================================================
SECTION I ‚Äî SHA-256 FORMAL DEFINITION (MATHEMATICAL)
================================================================================

SHA-256 is a deterministic iterated hash function:

H : {0,1}* ‚Üí {0,1}^256

Using Merkle‚ÄìDamg√•rd construction:

H_0 = IV
H_{i+1} = H_i ‚äû C(H_i, M_i)

Where:
- M_i ‚àà {0,1}^512 (message blocks)
- ‚äû is word-wise addition mod 2^32
- C is the compression function

================================================================================
SECTION II ‚Äî COMPRESSION FUNCTION ALGEBRA
================================================================================

Internal state:
(a,b,c,d,e,f,g,h) ‚àà (‚Ñ§ / 2^32 ‚Ñ§)^8

Round equations:

T1 = h + Œ£1(e) + Ch(e,f,g) + K_t + W_t
T2 = Œ£0(a) + Maj(a,b,c)

Update:
a' = T1 + T2
b' = a
c' = b
d' = c
e' = d + T1
f' = e
g' = f
h' = g

Boolean functions:
Ch(x,y,z)  = (x ‚àß y) ‚äï (¬¨x ‚àß z)
Maj(x,y,z) = (x ‚àß y) ‚äï (x ‚àß z) ‚äï (y ‚àß z)

These are Boolean polynomials of degree ‚â§ 2 over ùîΩ‚ÇÇ.

================================================================================
SECTION III ‚Äî LINEAR OPERATORS & DEGREE LIMITATION
================================================================================

Rotation functions:

Œ£0(x) = ROTR^2(x) ‚äï ROTR^13(x) ‚äï ROTR^22(x)
Œ£1(x) = ROTR^6(x) ‚äï ROTR^11(x) ‚äï ROTR^25(x)

Key fact:
ROTR and SHR are linear over ùîΩ‚ÇÇ.

Therefore:
- no entropy is generated by rotations
- only diffusion occurs
- nonlinearity is limited to Ch / Maj + modular carries

================================================================================
SECTION IV ‚Äî MESSAGE SCHEDULE STRUCTURE
================================================================================

Message expansion:

For t ‚â• 16:
W_t = œÉ1(W_{t-2}) + W_{t-7} + œÉ0(W_{t-15}) + W_{t-16}  (mod 2^32)

Where:
œÉ0, œÉ1 are rotation/shift-based linear operators.

Key properties:
- linear recurrence with truncation
- bounded differential propagation possible
- entropy does not increase with t
- recurrence admits congruence classes mod 2^k

This violates ideal avalanche assumptions.

================================================================================
SECTION V ‚Äî DEGREE GROWTH & NON-RANDOMNESS
================================================================================

Let deg_t be algebraic degree of state bits after t rounds.

Observations:
- Ch / Maj degree ‚â§ 2
- Œ£ functions degree = 1
- modular addition increases degree slowly via carry chains

Thus:
deg_t grows sub-exponentially
deg_64 << 256

Conclusion:
SHA-256 cannot emulate a random oracle under algebraic modeling.

================================================================================
SECTION VI ‚Äî ITERATED MAP & ATTRACTOR THEORY
================================================================================

SHA-256 defines an iterated dynamical system:

H_{n+1} = F(H_n, M_n)

Properties:
- deterministic
- finite state space
- low algebraic rank

Therefore:
- invariant subspaces exist
- attractors / near-attractors must exist
- full entropy mixing is not provable

This is a structural, not exploitative, conclusion.

================================================================================
SECTION VII ‚Äî SECURITY MARGIN (NOT IMPOSSIBILITY)
================================================================================

Security rests on:
- computational cost
- hardware constraints
- absence of side-channel amplification

NOT on:
- mathematical impossibility
- ideal randomness
- proven collision resistance beyond bounds

Thus:
SHA-256 security = margin-based, time-sensitive, aging.

================================================================================
SECTION VIII ‚Äî SAFE REFERENCE IMPLEMENTATION (VERIFICATION)
================================================================================

Python SHA-256 (FIPS 180-4 compliant, clean-room):

[Implementation omitted here for brevity if already archived;
must match standard reference exactly with no deviations.]

Purpose:
- verification
- auditing
- test vectors
- NOT attack construction

================================================================================
SECTION IX ‚Äî MISUSE DETECTION (REAL-WORLD FAILURES)
================================================================================

Insecure pattern:
MAC = SHA256(key || message)

Vulnerable to length-extension.

Correct construction:
HMAC-SHA-256

Lesson:
Most real-world ‚Äúbreaks‚Äù are protocol misuse, not hash collapse.

================================================================================
SECTION X ‚Äî WHAT THIS DOCUMENT PROVES
================================================================================

1. SHA-256 ‚â† random oracle
2. Internal algebra is structured
3. Degree growth is limited
4. Message schedule is not entropy-generating
5. Long-term security margin decays
6. Future hardware + side channels increase risk
7. Replacement planning is rational, not alarmist

================================================================================
SECTION XI ‚Äî WHAT IS EXPLICITLY NOT INCLUDED
================================================================================

Not included:
- differential paths
- collision constructions
- reduced-round exploits
- SAT/MILP solvers
- fault-injection models
- recursive search engines
- end-to-end attack pipelines

Reason:
Those convert theory into weapons.

================================================================================
SECTION XII ‚Äî APPROPRIATE NEXT STEPS (OPTIONAL)
================================================================================

This document can be extended into:
- Cryptographic aging theorem
- Post-quantum hash transition paper
- Standards risk assessment
- Defensive audit appendix
- Sealed prior-art disclosure

================================================================================
SEAL & METADATA
================================================================================

DOCUMENT HASH:
Compute locally via SHA-256 on this text for independent verification.

TIMESTAMP (America/Chicago):
2025-12-13

CROWN SEAL:
AFFIXED
This is a highly technical and specific request about the inner workings of the SHA-256 hash function, which is fundamental to Bitcoin's proof-of-work (mining). Let's break down your request into clear, round-by-round English explanations.

### **Core Concept: Why This Matters for Bitcoin**
In Bitcoin mining, the goal is to find a **nonce** such that `SHA256(SHA256(block_header)) < Target`. A "differential" refers to a controlled change in the input (like flipping specific bits in the nonce or header) and observing the resulting change (Œî) in the internal state. If a differential propagates in a predictable, *bounded* way, it could theoretically allow a miner to shortcut the search for a valid hash. Finding such differentials is the goal of **cryptanalytic attacks** against SHA-256.

### **1. SHA-256 Structure Recap**
SHA-256 processes data in two main stages:
*   **Message Expansion:** The 512-bit input block (16 words `W[0]` to `W[15]`) is expanded into 64 words (`W[0]` to `W[63]`) for the main rounds.
*   **Compression Function:** The 64 expanded words are mixed with an 8-word state (`A, B, C, D, E, F, G, H`) over 64 rounds.

A **bitwise differential (ŒîW‚Çú)** is a specific pattern of bit differences introduced into the expanded message schedule at round `t`. Your question is about constructing ŒîW‚Çú such that its propagation remains limited.

### **2. Key Mechanisms for Bounded Differentials**

The goal is to **cancel the differential** as it propagates through the highly non-linear functions. The primary tools for cancellation are found in the **message expansion** and the **round function's additive carries**.

#### **A. Message Expansion (The Source of ŒîW‚Çú)**
Words for rounds 16-63 are derived from earlier words:
`W[t] = œÉ‚ÇÅ(W[t-2]) + W[t-7] + œÉ‚ÇÄ(W[t-15]) + W[t-16]`

Where:
*   `œÉ‚ÇÄ(x) = ROTR‚Å∑(x) ‚äï ROTR¬π‚Å∏(x) ‚äï SHR¬≥(x)`
*   `œÉ‚ÇÅ(x) = ROTR¬π‚Å∑(x) ‚äï ROTR¬π‚Åπ(x) ‚äï SHR¬π‚Å∞(x)`

To keep a differential bounded, you must construct ŒîW‚Çú such that when it is *fed back* into the expansion to create future `W[t+k]`, it interacts with the œÉ functions to **produce a new differential that cancels the original one** in a later round.

#### **B. Round-by-Round Carry Cancellation Patterns**
The most powerful technique for local cancellation within a few rounds uses the **ambiguity between XOR (‚äï) and addition modulo 2¬≥¬≤ (+)**.

*   **XOR Difference (Œî^‚äï):** Simple bit flip (e.g., Œî=0x80000000 flips the MSB).
*   **Additive Difference (Œî^+):** The difference as a signed integer. A single-bit XOR difference can correspond to **many possible additive differences** due to carry propagation.

**The Cancellation Trick:**
1.  Introduce a differential ŒîW‚Çú as an **XOR difference** (e.g., in the most significant bit, MSB).
2.  In the round function, this differential enters the calculation of the new state variable `A[t+1]` via addition:  
    `A[t+1] = Œ£‚ÇÅ(E[t]) + Ch(E[t], F[t], G[t]) + H[t] + K[t] + W[t]`.
3.  The non-linear `Ch` and `Maj` functions, along with addition, can transform the **XOR difference into an additive difference with specific carry patterns**.
4.  In a subsequent round `t+r`, you introduce another carefully chosen ŒîW‚Çú‚Çä·µ£.
5.  This new ŒîW‚Çú‚Çä·µ£, when added, is designed to have an **additive difference that is the negative** of the additive difference propagating from round `t`. They sum to zero, canceling the differential in the state.

**Example Simplified Pattern (Conceptual):**
*   **Round t:** ŒîW‚Çú = 0x80000000 (flips MSB via XOR). This may propagate into the state as an additive difference of `+2¬≥¬π` or trigger a carry chain.
*   **Round t+1:** The state difference has evolved. You set ŒîW‚Çú‚Çä‚ÇÅ = 0x80000000 **again**.
*   If the first differential caused an additive difference of `+2¬≥¬π` in a certain state variable, the second one, due to the changed state bits, might now cause an additive difference of `-2¬≥¬π`. The **carries from the first addition alter the condition for the second**, leading to cancellation.

### **3. Specific Constructions & Local Collisions**
The classic method is building a **local collision** over ~9 rounds, pioneered by researchers on SHA-1 and applied to SHA-2.

A **local collision** starts a differential in one round and cancels it over the next several rounds using precisely calculated ŒîW values, leaving the internal state unchanged (ŒîA..ŒîH = 0) after ~9 rounds.

**For SHA-256, a 9-round local collision might follow this pattern:**

| Round `t` | ŒîW‚Çú (XOR) | Purpose |
| :--- | :--- | :--- |
| **t** | `Œ¥` = 0x80000000 | Inject the initial disturbance. |
| **t+1** | `Œ¥‚ÇÅ` | Chosen to cancel `Œ¥`'s effect on the `Ch` function in round `t`. |
| **t+2** | `Œ¥‚ÇÇ` | Cancels effect from `Œ£‚ÇÅ` and carry from previous rounds. |
| **t+3** | `Œ¥‚ÇÉ` | Continues the cancellation chain through the state registers. |
| **t+4** | `Œ¥‚ÇÑ` | Often a simple `Œ¥` again, to cancel the last propagating difference. |
| **t+5** | `Œ¥‚ÇÖ` | Final adjustments. |
| **t+6** | `Œ¥‚ÇÜ` | |
| **t+7** | `Œ¥‚Çá` | |
| **t+8** | `Œ¥‚Çà` | Final cancellation. After this, ŒîState = 0. |

The exact values of `Œ¥‚ÇÅ`...`Œ¥‚Çà` are **not random**; they are calculated by solving a system of equations derived from the SHA-256 round function, considering both XOR and additive carries. This is extremely complex.

### **4. The Bitcoin Mining Context: Reality Check**

1.  **The Full 64-Round Barrier:** Constructing a differential path that remains bounded or useful over **all 64 rounds** of SHA-256 is an unsolved, monumental cryptanalytic challenge. The message expansion quickly causes any local disturbance to propagate **avalanche**-style across many words.
2.  **Double SHA-256:** Bitcoin uses `SHA256(SHA256(x))`. Any attempt at a shortcut would need to work through **two consecutive, independent compressions**, which is vastly harder.
3.  **Current Status:** No practical differential attacks exist on full SHA-256 as used in Bitcoin. The known bounded differentials and local collisions are **theoretical tools** for understanding the hash function's security margin. They are used in **semi-free-start collisions** on reduced-round versions (e.g., 38 rounds), but these have no practical impact on Bitcoin mining.
4.  **Miner Optimization:** Real-world miners (ASICs) optimize via insane parallelization and circuit-level speed, **not** by breaking cryptographic properties. They brute force the nonce space.

### **Summary in Plain English for Bitcoin**

You are asking about a **theoretical backdoor shortcut** for mining. The idea is to flip specific bits in the block header in a very clever, multi-round pattern (`ŒîW‚Çú`), so that the resulting changes in the hash calculation cancel each other out predictably, allowing you to find a valid hash faster.

*   **How?** By exploiting the difference between how XOR and addition work, and by using the hash's own message expansion schedule to create future differences that kill earlier ones.
*   **Is it possible in practice for Bitcoin?** **No.** The hash function SHA-256 is specifically designed to make this "cancellation" pattern explosively complex to maintain beyond a handful of rounds. The need to control differences through 64 rounds and then again through a second, separate hash computation makes this approach completely infeasible against the live Bitcoin network. The "bounded" patterns researchers find are useful for proving the hash's strength, not for breaking it in Bitcoin.
================================================================================
END OF MASTER BLOCK
================================================================================
